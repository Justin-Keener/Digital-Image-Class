import cv2 
import numpy as np
import matplotlib.pyplot as plt
import numpy as np


# Creates the path for the first image and reads the image into a variable
img_path = "/Users/justinkeener/Desktop/Digital-Image-Class/images/tree.JPG"
img = cv2.imread(img_path)

# Creathes the path for the second image and reads the image into a variable
img2_path = "/Users/justinkeener/Desktop/Digital-Image-Class/images/deer.JPG"
img2 = cv2.imread(img2_path,0)

# Creates the path for the third image, reads the image into a variable, and converts the image to RGB
img3_path = "/Users/justinkeener/Desktop/Digital-Image-Class/images/peacoke feather.JPG"
img3 = cv2.imread(img3_path)
RGB_img = cv2.cvtColor(img3, cv2.COLOR_BGR2RGB)

#Creates the path for the fourth image, reads the image into a variable, and converts it to grayscale image
img4_path = '/Users/justinkeener/Desktop/Digital-Image-Class/images/keanu karate.jpg'
img4 = cv2.imread(img4_path,0)

# Creats the path for the template image, reads the template image into a variable, and converts it to grayscale image
template_path = '/Users/justinkeener/Desktop/Digital-Image-Class/images/template.jpg'
template = cv2.imread(template_path,0)

""" ------Gamma Correction------ 

    Parameters: img, gamma
    
    Description: 
    - Function adjust_gamma maps the output image pixels to be stored in a lookup table based on the original image pixel values.
    - invGamma calculates the inverse gamma that is applied to counter the gamma value generated by the computer screen.
    - Variable table traverses through input pixel to calculate each pixel for output image then those
      values are stored in a lookup table.
    - np.arange ranges the pixels from 0 to 255
    - for loop evenly spaces the pixels in a table to range from interval [0 to 255] and ensures the table is unsigned 8bit

    O = (I/255)^(gamma) = mapped output values from input image pixel values
"""

def adjust_gamma(img, gamma):
    invGamma = 1.0/gamma
    table  = np.array([((i / 255.0) ** invGamma) * 255
        for i in np.arange(0,256)]).astype("uint8")
    return cv2.LUT(img,table)

# Plots and scales to enlarge the original image
plt.figure(figsize=(25,25))
plt.subplot(221), plt.imshow(img),plt.title("Original Image")

# Calls the original image and gamma value to the adjust_gamma function for gamma correction 
correction1 = adjust_gamma(img,0.5)

# Plots a output image with a 0.5 gamma to darken the original image
plt.subplot(222),plt.imshow(cv2.putText(correction1, "g = {}".format(0.5),(20,80),cv2.FONT_HERSHEY_DUPLEX, 3.0, (0, 255, 0), 3))
plt.title("1st Gamma Correction")  

# Plots another output image with a 1.5 gamma to brighten the original image
correction2 = adjust_gamma(img,1.5)
plt.subplot(223),plt.imshow(cv2.putText(correction2, "g = {}".format(1.5),(20,80),cv2.FONT_HERSHEY_DUPLEX, 3.0, (255, 255, 255), 3))
plt.title("2nd Gamma Correction") 

# Plots the last output image with a 2.5 gamma to incredibly increase the brightness of the original image
correction3 = adjust_gamma(img,2.5)
plt.subplot(224),plt.imshow(cv2.putText(correction3, "g = {}".format(2.5),(20,80),cv2.FONT_HERSHEY_DUPLEX, 3.0, (0, 0, 0), 3))
plt.title("3rd Gamma Correction")
plt.show()

""" 
------Histogram Equalization for Grayscale Image------ 

The sequence of code from lines 1-11 is the mathematical process of determining the cdf to be implemented 
as the Equalized Transformation function to a source image. The plot of the cdf is shown for the source image
and the equalized image to distinguish. Cdf for the equalized image is suppose to represent an increasing linear function in the 
form of steps.

"""
# [1] unpacks the histogram data into hist and the number of bins from 0 to 256 into variable bin
hist,bins = np.histogram(img2.flatten(),256,[0,256])

# [2] Calculates the cdf probability for the histogram
cdf = hist.cumsum()

# [3] Calulates the cdf probability to be normalized to [0,255]
cdf_normalized = cdf * hist.max()/ cdf.max()

# [4] Plots the gray scale image next to the histogram
plt.figure(figsize= (10,10))
plt.subplot(221),plt.imshow(img2, cmap = 'gray'),plt.title("Grayscale Image")
plt.subplot(222),plt.plot(cdf_normalized, color = 'b'),plt.hist(img2.flatten(),256,[0,256], color = 'r'),plt.xlim([0,256]),plt.title("Grayscale Histogram")

# [5] Returns the masked values of the cdf curve except for 0
cdf_m = np.ma.masked_equal(cdf,0)

# [6] General Histogram Equalization formula: h(v) = ((cdf(v)-cdfmin)/((M x N) - 1) x (L-1)
cdf_m = (cdf_m - cdf_m.min())*255/(cdf_m.max()-cdf_m.min())

# [7] Returns cdf to have the masked values of cdf_m replaced with fill values from 1 to 255
cdf = np.ma.filled(cdf_m,0).astype('uint8')

# [8] Transforms a new image to be an equalized image of the source image using cdf as the transform
eq_img = cdf[img2]

# [9] Unpacks the data as one dimension for the histogram and determines the range for bins
hist,bins = np.histogram(eq_img.flatten(),256,[0,256])

# [10] Calculates the cdf probability for the histogram
cdf = hist.cumsum()

# [11] Calulates the cdf probability to be normalized to [0,255]
cdf_normalized = cdf * hist.max()/ cdf.max()

# Plots the grayscale image next to the equalized grayscale histogram
plt.subplot(223),plt.imshow(eq_img, cmap = 'gray'),plt.title("Gray Scale Equalized Image")
plt.subplot(224),plt.plot(cdf_normalized, color = 'b'),plt.hist(eq_img.flatten(),256,[0,256], color = 'r'),plt.xlim([0,256]),plt.title("Grayscale Equalized Histogram")

plt.show()

"""------Template Matching------"""

# Dimensions of the template
w, h = template.shape[::-1]

# Cross Correlation Method
method = ['cv2.TM_CCORR_NORMED']

# Traverses through the correlation method to determine the location of the image in the image source 
for corr_method in method:
    img5 = img4.copy()
    method = eval(corr_method)

    # Apply template Matching
    res = cv2.matchTemplate(img5,template,method)
    min_val, max_val, min_loc, max_loc = cv2.minMaxLoc(res)
    
    # Rectangle starts at the top left and ends at the bottom right
    # Input image is of size (WxH) and template image is of size (wxh), output image will have a size of (W-w+1, H-h+1)
    top_left = max_loc
    bottom_right = (top_left[0] + w, top_left[1] + h)

    cv2.rectangle(img5,top_left, bottom_right, 255, 2)
    
    # Plots the Matching Result and Detection Point
    plt.subplot(121),plt.imshow(res,cmap = 'gray')
    plt.title('Matching Result'), plt.xticks([]), plt.yticks([])
    plt.subplot(122),plt.imshow(img5,cmap = 'gray')
    plt.title('Detected Point'), plt.xticks([]), plt.yticks([])

    plt.show()